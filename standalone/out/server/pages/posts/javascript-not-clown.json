{"pageProps":{"post":{"title":"شوخی‌های پشت وانتی با جاوااسکریپت","description":"هر بار بحثی درمورد جاوااسکریپت میشه توی گروه‌ها، با دریایی از memeها رو به رو میشیم. کافیه یکی بپرسه جاوااسکریپت زبان خوبیه؟ یا می‌خوام جاوااسکریپت رو شروع کنم…","date":"2020-06-12","slug":"javascript-not-clown","tags":["programming"],"content":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    br: \"br\",\n    code: \"code\",\n    img: \"img\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"هر بار بحثی درمورد جاوااسکریپت میشه توی گروه‌ها، با دریایی از memeها رو به رو میشیم. کافیه یکی بپرسه جاوااسکریپت زبان خوبیه؟ یا می‌خوام جاوااسکریپت رو شروع کنم…\", _jsx(_components.br, {}), \"\\n\", \"توی این پست میخوایم یکی از معروف‌ترینه این memeها رو بررسی کنیم و ببینیم که واقعا داستان پشتشون چیه و چرا جاوااسکریپت اینقدر احمق به نظر میاد. چون آخر کار ممکنه فراموش کنم این رو بنویسیم، همینجا میگم بهتون که اینا بامزه هستن و برای meme درست کردن خوبن، ولی توی کار واقعی به چنین مواردی بر نمیخورید احتمالا. اکثر این‌ها هم مربوط به جاوااسکریپت ES5 هست و تا حالا که نسخه‌های متعددی اومده و به استانداردهای ES9 رسیدیم، اکثر این بامزه‌ها رو از دست دادیم و جایگزین‌های بسیار کارایی براشون وجود داره. کافیست دیگه، بریم و شروع کنیم\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://res.cloudinary.com/practicaldev/image/fetch/s--ZDtqrBOj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/damiancipolat/js_vs_memes/blob/master/doc/js_thanks.png%3Fraw%3Dtrue\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typeof\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NaN\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"number\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"1- مقدار NaN برای اعداد ناشناخته هست در نتیجه عدد هست (\", _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/NaN\",\n        children: \"MDN\"\n      }), \")\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"9999999999999999\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 10000000000000000\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"2- جاوااسکریپت از float 64 بیتی استفاده میکنه، با Number.MAX_SAFE_INTEGER می‌تونید حداکثر عدد ممکن رو ببینید، کماکان میگم که توی پروژه‌های معمولی به حداکثر فلوت 64 بیتی رسیدن کار ساده‌ای نیست ولی اگر رسیدید هم نگران نباشید، میتونید از \", _jsx(_components.a, {\n        href: \"https://mathjs.org/docs/datatypes/bignumbers.html\",\n        children: \"MathJS\"\n      }), \" استفاده کنید و هر عددی خواستید رو استفاده کنید (با استفاده از آرایه‌ها عددها رو ذخیره میکنه)\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.5\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.1\"\n        }), \" == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.6\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// true\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"3- درمورد این حرفی برای زدن نیست، 0.6 با 0.6 برابر هست؟ بله هست\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.1\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.2\"\n        }), \" == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.3\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// false\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"4- این یکی خوبه واقعا، خوشم میاد از این\", _jsx(_components.br, {}), \"\\n\", \"اینا داستان تبدیل عدد دودویی به ده‌دهی هست، مثلا عدد پی رو اگر در نظر بگیرید بی اندازه اعشار داره ولی فقط دو رقمش رو در نظر میگیریم، تبدیل اعدد اشاری ده‌دهی به دودویی هم داره همین داستان رو، بی اندازه اعشار داره که رُند میشه، در نتیجه عدد همیشه اونی که ما فکر میکنیم نیست\", _jsx(_components.br, {}), \"\\n\", \"در واقع چیزی که داره مقایسه میشه اینا هستن…\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [\"    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.1\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.2\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.30000000000000004\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.30000000000000004\"\n        }), \" == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.3\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// false\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"فقط هم مربوط به جاوااسکریپت نیست. راه حل هم براش زیاده ولی \", _jsx(_components.strong, {\n        children: _jsx(_components.a, {\n          href: \"https://dev.to/alldanielscott/how-to-compare-numbers-correctly-in-javascript-1l4i\",\n          children: \"اینجا\"\n        })\n      }), \" ساده و سر راست توضیح داده\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// -Infinity\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"5- حداکثر مقدار یک آرایه‌ی خالی، بیرون از آرایه قرار داره… در منفی بی‌نهایت! شیوه‌ی درست استفاده از این تابع ساده هست، Math.max(10, 5, 4, 9) و واقعا پیش نمیاد این ولی خوب منطقی هست که بزرگترین عدد آرایه‌ی خالی بیرونش باشه\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"min\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Infinity\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"6- اینم مشابه بالایی هست، بیشترین از اون طرف لیست می‌افته بیرون، کمترین از این طرف اگر لیست کلا خالی باشه\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [\";[] + []\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"7- علامت + هم برای concatenate یا چسبودن استفاده میشه هم برای جمع کردن (هرچند توی ES6 به بعد یه روش جایگزین خیلی خوب هست که میگم براتون)\", _jsx(_components.br, {}), \"\\n\", \"خوب با توضیح بالا جاوااسکریپت تلاش میکنه این دو رو به هم بچسبونه و یک استرینگ تحویل بده. نتیجه میشه این\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"” ” + ” ” = ” “\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [\";[] + {}\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"[object Object]\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"8- نوع داده به سمت چپ تبدیل میشه، اینجا چون آرایه سمت چپ هست و قرار هست concatenate (چسبونده) بشه به بغلیش، آبجکت تبدیل به متن شده\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [\"{\\n}\\n;+[]\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 0\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"9- اینجا هم به نوع سمت چپ تبدیل میشه، در نتیجه\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [\"    {} تبدیل به \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" شده\\n    [] تبدیل به صفر شده\\n    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"نکته: دلیل این تبدیل‌ها، داینامیک تایپ بودن جاوااسکریپت هست، یعنی نیاز نیست شما نوع داده رو مشخص کنید مثل Cpp مثلا که اگر بخواید میتونید مشخص هم کنید با پیش پردازنده‌ای مثل TypeScript یا FlowType، بستگی به نوع پروژتون داره و انتخاب‌های زیادی هم دارید همیشه\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 3\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"10- مقدار true همیشه ۱ هست و مقدار false همیشه ۰، یک استاندارد رایج بین زبون‌های برنامه نویسی و حتی پایگاه‌های داده هست. در نتیجه که\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"1 + 1 + 1 === 3 ؟ بله هست\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" - \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 0\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"11- این همون داستان بالا هست، ۱ – ۱ میشه ۰\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// true\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"12- با همون تعریف‌های بالا، ۱ == ۱ هست؟ بله\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" === \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// false\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"13- همونطور که میدونیم، === علاوه بر مقدار، نوع رو هم بررسی میکنه، این دو مقدارشون یکی هست ولی نوعشون خیر، درواقع\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typeof\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" -> boolean\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typeof\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" -> number\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"پس با اینکه مقدارشون یکی هست ولی چون نوع‌هاشون یکی نیست این مقایسه false میشه\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [\";(!+[] + [] + ![]).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"length\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 9\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"14- روند اینم بامزه هست، ببینم با هم چه اتفاقی داره می‌افته\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [\"    ![] = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n    (!+[]): \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n    ([]+![]): \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"false\\\"\"\n        }), \" به عنوان متن\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"truefalse\\\"\"\n        }), \" چسبیدن به عنوان دوتا متن\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"truefalse\\\"\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"length\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"9\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"در نتیجه در نهایت طول trueFalse سر هم باید حساب بشه که میشه 9 تا\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"9\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'1'\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 91\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"15- بالاتر هم درموردش گفتیم، اینجا + داره concatenate میکنه این دوتا رو به هم دیگه و ربطی به جمع نداره و حاصل استرینگ هست\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"91\"\n        }), \" - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 90\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"16- اینجا عملگر – هر دو سمت رو عدد میکنه تا تفریق رو انجام بده، در نتیجه حاصل عدد هست\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [\";[] == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// true\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"17- تبدیل [ ] به عدد که حاصل 0 هست و مقایسه با 0\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"برای نکات پایانی هم باید بدونیم که جاوااسکریپت چون وظیفه‌ی اجرا شدن روی قدیمی‌ترین مرورگرها تا پیش‌رفته ترین سرورها رو داره، چیزهایی که منسوخ شدن رو حذف نمیکنه، هستند ولی نباید توی نوشتن برنامه‌ی تازه ازشون استفاده کنیم. حتما از ESLint و ابزارهای مشابه استفاده کنید تا درمورد چیزهای منسوخ شده بهتون هشدار بدن\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"برای چسبوندن متن‌ها به هم و گذاشتن متغیر از این روش استفاده کنید\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// !!! منسوخ شده !!!\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" name = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Saleh'\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" age = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"20\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" city = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Shiraz'\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Name is '\"\n        }), \" +\\n    name +\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'\\\\n'\"\n        }), \" +\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Age is: '\"\n        }), \" +\\n    age +\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'\\\\n'\"\n        }), \" +\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'City is: '\"\n        }), \" +\\n    city +\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'\\\\n'\"\n        }), \"\\n)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ** استاندارد تازه **\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" name = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Saleh'\"\n        }), \",\\n  age = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"20\"\n        }), \",\\n  city = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Shiraz'\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`\\n    \\tName is : \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${name}\"\n          }), \"\\n    \\tAge is: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${age}\"\n          }), \"\\n    \\tCity is: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${city}\"\n          }), \"\\n    `\"]\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"برای مقایسه هم همیشه از === استفاده کنید نه ==\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"و همینطور اگر کار جدی‌ای با اعداد دارید، از کتابخونه‌های حرفه‌ای مثل MathJS و… استفاده کنید تا احتمال اینکه در آینده برنامتون یه وقتی به مشکل بخوره رو کمتر کنید\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"و نکته‌ی نهایی اینکه زبون‌ها برای استفاده هستند، از هرکدوم هرجایی که بهتر جواب میده استفاده کنید و لذت ببرید 📿🕶\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://dev.to/damxipo/javascript-versus-memes-explaining-various-funny-memes-2o8c\",\n        children: \"منبع اصلی\"\n      }), \" (dev.to)\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"coverImage":"/posts/javascript-not-clown.jpg","timeToRead":25}},"__N_SSG":true}